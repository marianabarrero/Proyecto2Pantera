<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pantera Tracker</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        .leaflet-container {
            height: 45rem; /* Ajusta según necesites */
            width: 100%;
            border-radius: 1rem;
            z-index: 10; /* Asegura que el mapa esté por encima del fondo */
        }
        body {
            font-family: "Poppins", sans-serif;
            overflow-x: hidden;
            scroll-behavior: smooth;
            background-color: #0f172a; /* Fondo base oscuro */
        }
        .glassmorphism-strong {
            background: rgba(15, 23, 42, 0.6); /* Fondo semi-transparente más oscuro */
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1); /* Borde sutil */
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .button-hover {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .button-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .animated-gradient-bg {
            position: fixed;
            inset: 0;
            z-index: -10;
            background: linear-gradient(-45deg, #0f172a, #1e293b, #075985, #0ea5e9);
            background-size: 400% 400%;
            animation: gradient-animation 25s ease infinite; /* Más lento */
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-spinner {
            width: 50px; height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top-color: #0ea5e9; /* Color sky-500 */
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        input[type="datetime-local"] {
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white; padding: 0.75rem; border-radius: 0.5rem; width: 100%;
        }
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            filter: invert(1) brightness(1.5); cursor: pointer;
        }
        .leaflet-popup-content-wrapper {
            background-color: rgba(15, 23, 42, 0.8) !important;
            color: #e2e8f0 !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3) !important;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .leaflet-popup-tip-container .leaflet-popup-tip {
            background-color: rgba(15, 23, 42, 0.8) !important;
        }
        .leaflet-popup-content strong {
            color: #67e8f9;
        }
        .leaflet-popup-content small {
            color: #94a3b8;
        }
        .marker-icon-red { filter: hue-rotate(0deg) saturate(1.5); }
        .marker-icon-blue { filter: hue-rotate(180deg) saturate(1.5); }
        .marker-icon-green { filter: hue-rotate(90deg) saturate(1.5); }
        .marker-icon-purple { filter: hue-rotate(270deg) saturate(1.5); }
        .marker-icon-orange { filter: hue-rotate(30deg) saturate(2); }
        .marker-icon-cyan { filter: hue-rotate(150deg) saturate(1.5); }
        .marker-icon-yellow { filter: hue-rotate(60deg) saturate(2); }
        .marker-icon-pink { filter: hue-rotate(300deg) saturate(1.5); }
    </style>
</head>
<body class="text-slate-200">
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-leaflet/4.2.1/react-leaflet.min.js" integrity="sha512-GBlRcxH2/C1aL1CHJtLzrhQo6P/fS5B7jG/TjgaogqYJbIwFgoe/HiJ9/1oHhshgW1JbQ5hgP28Yf2D/iir1gA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script type="text/babel">
        // **CAMBIO AQUÍ**: Aseguramos que las variables de React y ReactLeaflet se tomen de 'window'
        const { useState, useEffect, useMemo, useCallback, useRef } = window.React;
        const { MapContainer, TileLayer, Marker, Popup, useMap, Polyline } = window.ReactLeaflet;

        // --- Configuración Básica ---
        const config = {
          API_BASE_URL: 'https://panteratracker.tech', 
          APP_NAME: 'Pantera Tracker',
          APP_VERSION: '4.0.1', // Nueva versión con corrección
          POLLING_INTERVAL: 8000, 
          DEVICE_ACTIVITY_THRESHOLD_MINUTES: 60,
        };

        // --- Colores e Iconos ---
        const deviceColors = [
            '#ef4444', '#3b82f6', '#22c55e', '#a855f7', '#f97316', '#06b6d4', '#eab308', '#ec4899'
        ];
        const iconClasses = [
            'marker-icon-red', 'marker-icon-blue', 'marker-icon-green', 'marker-icon-purple',
            'marker-icon-orange', 'marker-icon-cyan', 'marker-icon-yellow', 'marker-icon-pink'
        ];

        const getDeviceStyle = (deviceId, deviceStylesRef) => {
            if (!deviceStylesRef.current[deviceId]) {
                const index = Object.keys(deviceStylesRef.current).length % deviceColors.length;
                deviceStylesRef.current[deviceId] = {
                    color: deviceColors[index],
                    iconClass: iconClasses[index],
                    iconUrl: `https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png`, // Usar icono base más simple
                };
            }
            return deviceStylesRef.current[deviceId];
        };

        // --- Componentes UI ---
        const LoadingSpinner = () => ( <div className="flex flex-col items-center justify-center p-8 text-white"><div className="loading-spinner"></div><p className="mt-4">Cargando datos...</p></div> );
        const ErrorMessage = ({ error, onRetry, retryText = "Reintentar" }) => ( <div className="glassmorphism-strong mt-10 rounded-2xl w-full max-w-md mx-auto p-8 text-center"><div className="text-red-400 mb-4"><h3 className="text-xl font-bold">Atención</h3></div><p className="text-white/70 mb-4">{error}</p>{onRetry && (<button onClick={onRetry} className="px-4 py-2 bg-sky-600 hover:bg-sky-700 text-white rounded-lg transition-colors">{retryText}</button>)}</div> );
        const DateSearchModal = ({ isOpen, onClose, onSearch, selectedDeviceId }) => { const [startDate, setStartDate] = useState('');const [endDate, setEndDate] = useState('');const [isLoading, setIsLoading] = useState(false);const [error, setError] = useState(''); const handleSearch = async () => { if (!startDate || !endDate) {setError('Por favor selecciona una fecha de inicio y de fin.'); return;} if (new Date(endDate) < new Date(startDate)) {setError('La fecha de fin debe ser posterior a la de inicio.'); return;} setError(''); setIsLoading(true); try { await onSearch({ startDate: new Date(startDate).toISOString(), endDate: new Date(endDate).toISOString(), deviceId: selectedDeviceId }); onClose(); } catch (err) { setError(err.message || 'Error inesperado.'); } finally { setIsLoading(false); } }; const resetForm = () => { setStartDate(''); setEndDate(''); setError(''); }; useEffect(() => { if (!isOpen) resetForm(); }, [isOpen]); if (!isOpen) return null; return ( <div className="fixed inset-0 z-50 flex items-center justify-center p-4"><div className="absolute inset-0 bg-black/50 backdrop-blur-sm" onClick={onClose} /><div className="relative glassmorphism-strong rounded-2xl p-6 md:p-8 mx-4 w-full max-w-md transform"><h2 className="text-xl md:text-2xl font-bold text-white mb-6">Seleccionar Rango de Fechas{selectedDeviceId && <span className="text-sm font-normal text-slate-400 block"> para Disp. {selectedDeviceId.substring(0,6)}...</span>}</h2><div className="space-y-4"><div><label htmlFor="startDate" className="block text-sm font-medium text-gray-300 mb-1">Fecha de Inicio</label><input type="datetime-local" id="startDate" value={startDate} onChange={e => setStartDate(e.target.value)} max={new Date().toISOString().slice(0, 16)} /></div><div><label htmlFor="endDate" className="block text-sm font-medium text-gray-300 mb-1">Fecha de Fin</label><input type="datetime-local" id="endDate" value={endDate} onChange={e => setEndDate(e.target.value)} min={startDate} disabled={!startDate} max={new Date().toISOString().slice(0, 16)} /></div></div>{error && <div className="mt-4 text-center text-red-400 bg-red-900/50 p-3 rounded-xl">{error}</div>}<div className="flex gap-4 pt-6 mt-4 border-t border-white/20"><button onClick={resetForm} disabled={isLoading} className="flex-1 px-4 py-2 md:px-6 md:py-3 bg-white/10 hover:bg-white/20 text-white rounded-xl transition-all font-medium text-sm md:text-base">Limpiar</button><button onClick={handleSearch} disabled={isLoading || !startDate || !endDate} className="flex-1 inline-flex items-center justify-center gap-2 px-4 py-2 md:px-6 md:py-3 bg-gradient-to-r from-sky-600 to-sky-700 hover:from-sky-700 hover:to-sky-800 text-white rounded-xl transition-all font-medium disabled:opacity-50 text-sm md:text-base">{isLoading ? 'Buscando...' : 'Buscar Historial'}</button></div></div></div> ); };

        // --- Componente de Información Lateral ---
        const DeviceInfoPanel = ({ devices, formatTimestamp, onOpenDateSearch, selectedDevice, onSelectDevice }) => (
            <div className='flex flex-col p-6 rounded-2xl glassmorphism-strong w-full h-full'>
                <h2 className='text-2xl font-bold text-white text-center mb-4'>Dispositivos Activos</h2>
                
                <select
                    value={selectedDevice || 'all'}
                    onChange={(e) => onSelectDevice(e.target.value === 'all' ? null : e.target.value)}
                    className="w-full p-3 mb-4 bg-slate-800/60 border border-slate-700 text-white rounded-xl focus:outline-none focus:ring-2 focus:ring-sky-500 transition text-sm"
                >
                    <option value="all">Ver Todos ({Object.keys(devices).length})</option>
                    {Object.keys(devices).sort().map(deviceId => (
                        <option key={deviceId} value={deviceId}>
                            Disp: {deviceId.substring(0, 8)}...
                        </option>
                    ))}
                </select>

                <div className="flex-grow overflow-y-auto space-y-3 pr-2">
                    {selectedDevice && devices[selectedDevice] ? (
                        <div key={selectedDevice} className="p-3 bg-slate-800/40 rounded-lg border border-sky-700">
                             <h3 className="text-lg font-semibold text-sky-400 mb-2">Disp: {selectedDevice.substring(0, 8)}...</h3>
                             <InfoRow label="Latitud" value={parseFloat(devices[selectedDevice].latitude).toFixed(6)} isMono={true} />
                             <InfoRow label="Longitud" value={parseFloat(devices[selectedDevice].longitude).toFixed(6)} isMono={true} />
                             <InfoRow label="Últ. Vez" value={formatTimestamp(devices[selectedDevice].timestamp_value)} isMono={true} />
                             <button
                                onClick={() => onOpenDateSearch(selectedDevice)}
                                className='button-hover mt-3 w-full text-sm inline-flex items-center justify-center gap-2 font-semibold rounded-lg transition-all duration-300 cursor-pointer bg-sky-700/80 text-white hover:bg-sky-600 px-3 py-2'
                            >
                                Ver Historial
                            </button>
                        </div>
                    ) : (
                        Object.entries(devices).length > 0 ? (
                             Object.entries(devices)
                             .sort(([, a], [, b]) => b.timestamp_value - a.timestamp_value) 
                             .map(([deviceId, location]) => (
                                <div key={deviceId} className="p-3 bg-slate-800/40 rounded-lg cursor-pointer hover:bg-slate-700/50" onClick={() => onSelectDevice(deviceId)}>
                                    <h3 className="text-base font-semibold text-sky-400 mb-1 truncate">Disp: {deviceId.substring(0, 8)}...</h3>
                                    <InfoRow label="Coords" value={`${parseFloat(location.latitude).toFixed(4)}, ${parseFloat(location.longitude).toFixed(4)}`} isMono={true} textSize="text-xs"/>
                                    <InfoRow label="Últ. Vez" value={formatTimestamp(location.timestamp_value)} isMono={true} textSize="text-xs"/>
                                </div>
                            ))
                        ) : (
                           <p className="text-center text-slate-400 mt-5">No hay dispositivos activos enviando datos.</p> 
                        )
                    )}
                </div>
            </div>
        );

        const InfoRow = ({ label, value, isMono, textSize = "text-sm" }) => (
            <div className={`flex justify-between items-center gap-2 py-0.5 ${textSize}`}>
              <h4 className='text-slate-400 whitespace-nowrap'>{label}:</h4>
              <span className={`text-slate-200 ${isMono ? 'font-mono' : ''} text-right truncate`}>{value}</span>
            </div>
        );

        // --- Componente del Mapa Modificado ---
        const LocationMap = ({ devices, formatTimestamp, devicePaths, deviceStylesRef, selectedDevice }) => {
            const mapRef = useRef();
            const [mapCenter, setMapCenter] = useState([4.6097, -74.0817]);
            const [mapZoom, setMapZoom] = useState(5);

            useEffect(() => {
                const map = mapRef.current;
                if (!map) return;

                const activeDevices = Object.values(devices);

                if (selectedDevice && devices[selectedDevice]) {
                    const pos = [parseFloat(devices[selectedDevice].latitude), parseFloat(devices[selectedDevice].longitude)];
                    map.flyTo(pos, 16, { duration: 1 });
                    setMapCenter(pos);
                    setMapZoom(16);
                } else if (activeDevices.length > 0) {
                    const bounds = L.latLngBounds(activeDevices.map(d => [parseFloat(d.latitude), parseFloat(d.longitude)]));
                    if (bounds.isValid()) {
                       map.flyToBounds(bounds, { padding: [50, 50], duration: 1.5 });
                    }
                } else {
                    map.flyTo([4.6097, -74.0817], 5, { duration: 1 });
                    setMapCenter([4.6097, -74.0817]);
                    setMapZoom(5);
                }
            }, [devices, selectedDevice]); 

            const createDeviceIcon = (deviceId) => {
                 const style = getDeviceStyle(deviceId, deviceStylesRef);
                 return L.icon({
                    iconUrl: style.iconUrl,
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                    shadowSize: [41, 41],
                    className: style.iconClass 
                 });
            };

            return (
                <div className='glassmorphism-strong rounded-2xl backdrop-blur-lg shadow-lg p-2 md:p-4 w-full h-full'>
                  <MapContainer
                    center={mapCenter}
                    zoom={mapZoom}
                    style={{ height: '100%', width: '100%', borderRadius: '0.75rem' }}
                    ref={mapRef}
                  >
                    <TileLayer
                      url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                      attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    />
                    
                    {Object.entries(devices).map(([deviceId, location]) => {
                         if(selectedDevice === null || selectedDevice === deviceId) {
                            const position = [parseFloat(location.latitude), parseFloat(location.longitude)];
                            const style = getDeviceStyle(deviceId, deviceStylesRef);
                            const path = devicePaths[deviceId] || [];
                           
                            return (
                                <React.Fragment key={deviceId}>
                                    <Marker position={position} icon={createDeviceIcon(deviceId)}>
                                      <Popup>
                                        <div className="text-center text-sm">
                                          <strong>Disp: {deviceId.substring(0, 8)}...</strong><br />
                                          <small>Recibido: {formatTimestamp(location.timestamp_value)}</small><br />
                                          <small>Lat: {position[0].toFixed(5)}</small>, 
                                          <small>Lng: {position[1].toFixed(5)}</small>
                                        </div>
                                      </Popup>
                                    </Marker>
                                    <Polyline pathOptions={{ color: style.color, weight: 3 }} positions={path} />
                                </React.Fragment>
                             );
                         }
                         return null;
                    })}
                  </MapContainer>
                </div>
              );
        };
        
        // --- Componente Principal APP Modificado ---
        function App() {
          const [activeDevices, setActiveDevices] = useState({});
          const [devicePaths, setDevicePaths] = useState({});
          const [loading, setLoading] = useState(true);
          const [error, setError] = useState(null);
          const [isDateSearchModalOpen, setIsDateSearchModalOpen] = useState(false);
          const [selectedDevice, setSelectedDevice] = useState(null);
          const [searchRangeData, setSearchRangeData] = useState(null);

          const deviceStylesRef = useRef({});

          const fetchActiveDevices = useCallback(async () => {
            setError(null);
            try {
              const response = await fetch(`${config.API_BASE_URL}/api/location/active_devices?minutes=${config.DEVICE_ACTIVITY_THRESHOLD_MINUTES}`);
              if (!response.ok) {
                throw new Error('Error al obtener dispositivos activos.');
              }
              const data = await response.json();
              setActiveDevices(data);

              setDevicePaths(prevPaths => {
                  const newPaths = { ...prevPaths };
                  Object.entries(data).forEach(([deviceId, location]) => {
                      const newPosition = [parseFloat(location.latitude), parseFloat(location.longitude)];
                      const currentPath = newPaths[deviceId] || [];
                      const lastPoint = currentPath[currentPath.length - 1];

                      if (!lastPoint || lastPoint[0] !== newPosition[0] || lastPoint[1] !== newPosition[1]) {
                          const updatedPath = [...currentPath, newPosition].slice(-100); 
                          newPaths[deviceId] = updatedPath;
                      }
                  });
                  const activeIds = Object.keys(data);
                  Object.keys(newPaths).forEach(id => {
                      if (!activeIds.includes(id)) {
                      }
                  });
                  return newPaths;
              });

            } catch (err) {
              setError(err.message || 'Error de conexión con el servidor.');
              console.error('Error fetching active devices:', err);
            } finally {
              setLoading(false);
            }
          }, []);

          useEffect(() => {
            fetchActiveDevices();
            const interval = setInterval(fetchActiveDevices, config.POLLING_INTERVAL);
            return () => clearInterval(interval);
          }, [fetchActiveDevices]);

          const handleDateSearch = async (searchParams) => {
            setLoading(true);
            setError(null);
            setSearchRangeData(null);
            setSelectedDevice(searchParams.deviceId); 

            try {
              const { startDate, endDate, deviceId } = searchParams;
              const deviceQuery = deviceId ? `&deviceId=${deviceId}` : '';
              const url = `${config.API_BASE_URL}/api/location/range?startDate=${startDate}&endDate=${endDate}${deviceQuery}`;
              const response = await fetch(url);

              if (!response.ok) {
                 const errorData = await response.json();
                 throw new Error(errorData.message || 'Error al obtener el historial.');
              }
              const historicalData = await response.json();

              if (historicalData.length > 0) {
                 const pathsInRange = {};
                 historicalData.forEach(point => {
                     const id = point.device_id;
                     if (!pathsInRange[id]) pathsInRange[id] = [];
                     pathsInRange[id].push([parseFloat(point.latitude), parseFloat(point.longitude)]);
                 });
                 setSearchRangeData(pathsInRange);
                 const lastLocationsInRange = {};
                 Object.keys(pathsInRange).forEach(id => {
                     const deviceData = historicalData.filter(p => p.device_id === id);
                     if(deviceData.length > 0) {
                         lastLocationsInRange[id] = deviceData[deviceData.length - 1];
                     }
                 });
                 setActiveDevices(lastLocationsInRange);

              } else {
                 setSearchRangeData({});
                 setActiveDevices(prev => selectedDevice ? ({...prev, [selectedDevice]: null}) : ({}));
                 setError('No se encontraron datos para el rango y dispositivo seleccionados.');
              }
            } catch (err) {
              setError(err.message);
              console.error('Error fetching date range:', err);
            } finally {
              setLoading(false);
            }
          };

          const returnToLiveMode = () => {
              setSearchRangeData(null);
              setSelectedDevice(null);
              setLoading(true);
              fetchActiveDevices();
          };

          const formatTimestamp = (timestamp) => { if (!timestamp) return 'N/A'; const date = new Date(parseInt(timestamp)); return date.toLocaleString('es-CO', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true }); };

          const pathsToShow = searchRangeData !== null ? searchRangeData : devicePaths;

          return (
            <div className="min-h-screen flex flex-col">
                <div className="animated-gradient-bg"></div>

                <header className="py-4 px-6 md:px-10 glassmorphism-strong shadow-md sticky top-0 z-20">
                    <h1 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-sky-400 to-cyan-300 text-transparent bg-clip-text text-center md:text-left">
                        {config.APP_NAME}
                    </h1>
                </header>

                <main className='flex-grow flex flex-col md:flex-row gap-4 md:gap-6 p-4 md:p-6 max-w-[1600px] w-full mx-auto'>
                    <div className="w-full md:w-1/4 h-[300px] md:h-auto md:max-h-[calc(100vh-100px)]">
                       {loading && Object.keys(activeDevices).length === 0 ? (
                           <div className="h-full flex items-center justify-center"><LoadingSpinner/></div>
                       ) : error && Object.keys(activeDevices).length === 0 ? (
                           <ErrorMessage error={error} onRetry={returnToLiveMode} retryText="Recargar"/>
                       ) : (
                           <DeviceInfoPanel 
                                devices={activeDevices} 
                                formatTimestamp={formatTimestamp} 
                                onOpenDateSearch={() => setIsDateSearchModalOpen(true)}
                                selectedDevice={selectedDevice}
                                onSelectDevice={setSelectedDevice}
                            />
                       )}
                    </div>
                    
                    <div className="w-full md:w-3/4 h-[500px] md:h-auto md:max-h-[calc(100vh-100px)]">
                      {loading && Object.keys(activeDevices).length === 0 ? (
                            <div className="h-full flex items-center justify-center glassmorphism-strong rounded-2xl"><LoadingSpinner/></div>
                       ) : !loading && Object.keys(activeDevices).length === 0 && !error ? (
                           <div className="h-full flex items-center justify-center glassmorphism-strong rounded-2xl text-center p-5">
                                <p className="text-slate-400">Esperando la primera señal de los dispositivos...</p>
                           </div>
                       ) : error && Object.keys(activeDevices).length === 0 ? (
                           <div className="h-full flex items-center justify-center glassmorphism-strong rounded-2xl">
                               <ErrorMessage error={error} onRetry={returnToLiveMode} retryText="Recargar"/>
                           </div>
                       ) : (
                           <LocationMap 
                                devices={activeDevices} 
                                formatTimestamp={formatTimestamp} 
                                devicePaths={pathsToShow} 
                                deviceStylesRef={deviceStylesRef}
                                selectedDevice={selectedDevice}
                            />
                       )}
                    </div>
                </main>

                 {searchRangeData !== null && (
                    <div className="fixed bottom-6 left-1/2 -translate-x-1/2 z-30">
                        <button
                          onClick={returnToLiveMode}
                          className="flex items-center gap-2 px-5 py-2.5 bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white rounded-full shadow-lg transition-all font-medium text-sm button-hover"
                        >
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v3.586L6.707 9.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 10.586V7z" clipRule="evenodd" /></svg>
                          Volver a Tiempo Real
                        </button>
                    </div>
                )}

                <DateSearchModal
                  isOpen={isDateSearchModalOpen}
                  onClose={() => setIsDateSearchModalOpen(false)}
                  onSearch={handleDateSearch}
                  selectedDeviceId={selectedDevice}
                />
            </div>
          );
        }
        
        // **CAMBIO AQUÍ**: Usamos ReactDOM.createRoot
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>

</body>
</html>